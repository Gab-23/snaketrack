import os
from snakemake.io import expand
from scripts.helpers.send_email import send_email

include: "rules/filter_selected_TxIDs.smk"

include: "rules/get_gencode_annotation.smk"
include: "rules/get_TSSs.smk"
include: "rules/sort_TSSs.smk"
include: "rules/filter_TSSs.smk"

include: "rules/filter_counts_new.smk"

include: "rules/get_mappability.smk"
include: "rules/filter_mappability.smk"
include: "rules/filter_CpGs_by_mappability.smk"
include: "rules/sort_CpGs.smk"

include: "rules/get_K_closest_CpGs.smk"

include: "rules/xgb_input.smk"

include: "rules/train_models.smk"
include: "rules/generate_feature_heatmap.smk"

include: "rules/aggregate_models_output.smk"
include: "rules/extract_CpGs_from_output.smk"
include: "rules/generate_genome_tracks.smk"
include: "rules/plot_models_output.smk"

include: "rules/get_chrom_sizes.smk"
include: "rules/clean_chrom_sizes.smk"
include: "rules/slop_TSSs.smk"
include: "rules/generate_ini_file.smk"
include: "rules/plot_genome_tracks.smk"
include: "rules/prepare_TSSs_to_plot_tracks.smk"

include: "rules/garbage_collector.smk"

sender = config["sender"][0]
app_password = config["app_password"][0]
recipients = config["recipients"]


assembly_codes = config["assembly_codes"]
gencode_versions = config["gencode_versions"]
tss_subsets = config["tss_subsets"]
sample_types = config["sample_types"]
distances = config["distances"]
min_CpGs = config["min_CpGs"]
leftCount_betas = config["leftCount_betas"]
rightCount_betas = config["rightCount_betas"]
minCount_exprs = config["minCount_exprs"]
minSamples_betas = config["minSamples_betas"]
minCovs = config["minCovs"]
minSamples_exprs = config["minSamples_exprs"]
importances = config["importances"]

rule all:
    input:
        expand(
            "resources/CpG_data/{assembly_code}_v{gencode_version}_{tss_subset}_{minCount_expr}_{minSamples_expr}.bed",
            assembly_code=assembly_codes,
            gencode_version=gencode_versions,
            tss_subset=tss_subsets,
            minCount_expr=minCount_exprs,
            minSamples_expr=minSamples_exprs
        )



def txids_from_checkpoint(wildcards):
    """Return list of TxIDs from checkpoint output (cached)."""
    chk_output = checkpoints.xgb_input.get(
        assembly_code=wildcards.assembly_code,
        sample_type=wildcards.sample_type,
        leftCount_beta = wildcards.leftCount_beta,
        rightCount_beta = wildcards.rightCount_beta,
        minSamples_beta = wildcards.minSamples_beta,
        minCov = wildcards.minCov,
        gencode_version=wildcards.gencode_version,
        tss_subset=wildcards.tss_subset,
        distance=wildcards.distance,
        min_CpG = wildcards.min_CpG,
        minCount_expr=wildcards.minCount_expr,
        minSamples_expr=wildcards.minSamples_expr
    ).output[2]

    with open(chk_output) as f:
        return [x.strip() for x in f]

def get_txid_train_outputs(wildcards):
    txids = txids_from_checkpoint(wildcards)
    return expand(rules.train_models.output.plot_path, TxID=txids, **wildcards)

def get_txid_tracks_outputs(wildcards):
    txids = txids_from_checkpoint(wildcards)
    return expand(rules.plot_genome_tracks.output, TxID=txids, **wildcards)

def get_txid_heatmap_outputs(wildcards):
    txids = txids_from_checkpoint(wildcards)
    return expand(rules.generate_feature_heatmap.output, TxID=txids, **wildcards)

rule run_all_models:
    input:
        get_txid_train_outputs
    output:
        all_done_txid="results/checks/train/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}"
    shell:
        """
        echo {input} >> {output.all_done_txid}
        """

rule plot_tracks:
    input:
        get_txid_tracks_outputs
    output:
        all_done_txid="results/checks/tracks/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}_{importance}"
    shell:
        """
        echo {input} >> {output.all_done_txid}
        """

rule plot_heatmaps:
    input:
        get_txid_heatmap_outputs
    output:
        all_done_txid="results/checks/heatmap/{assembly_code}_{sample_type}_{leftCount_beta}_{rightCount_beta}_{minSamples_beta}_{minCov}_v{gencode_version}_{tss_subset}_{distance}_{min_CpG}_{minCount_expr}_{minSamples_expr}"
    shell:
        """
        echo {input} >> {output.all_done_txid}
        """

wildcard_constraints:
    tss_subset="[a-z]+",
    distance = "[0-9]+",
    minSamples_beta = "[0-9]+",
    minCov = "[0-9]+",
    gencode_version="[0-9]+",
    minCount_expr="[0-9]+",
    assembly_code="hg\\d{2}",
    sample_type="[A-Z]",
    minCpG="[0-9]+",
    leftCount_beta="\\d+(\\.\\d+)?",
    rightCount_beta="\\d+(\\.\\d+)?",
    minSamples_expr="[0-9]+",
    K="[0-9]+",
    importance="[a-z]+"

onsuccess:

    dirs_to_clean = ["get_CpGs_by_TxID",
                    "get_transcriptome",
                    "subset_beta_matrix",
                    "generate_datasets",
                    "generate_genome_tracks",
                    "generate_feature_heatmap",
                    "extract_CpGs_from_output",
                    "train_models"]

    [
    os.system(
        f"for file in logs/{dir}/*; do cat $file >> logs/{dir}/{dir}_aggregated.log; done;"
        f"for file in logs/{dir}/*; do if [ $(basename $file) != {dir}_aggregated.log ]; then rm $file; fi  done;"
    )
    for dir in dirs_to_clean
]


    attachments = [f"logs/{path}/{elem}" for path in os.listdir("logs/") for elem in os.listdir(f"logs/{path}/")]
    send_email(subject = "Snakemake workflow - SUCCESS", 
            body = "The workflow completed successfully.",
            attachments=attachments,
            recipients=recipients, 
            sender=sender,
            app_password=app_password
    )

onerror:
    
    dirs_to_clean = ["get_CpGs_by_TxID",
                    "get_transcriptome",
                    "subset_beta_matrix",
                    "generate_datasets",
                    "generate_genome_tracks",
                    "generate_feature_heatmap",
                    "extract_CpGs_from_output",
                    "train_models"]

    [
    os.system(
        f"for file in logs/{dir}/*; do cat $file >> logs/{dir}/{dir}_aggregated.log; done;"
        f"for file in logs/{dir}/*; do if [ $(basename $file) != {dir}_aggregated.log ]; then rm $file; fi  done;"
    )
    for dir in dirs_to_clean
]


    attachments = [f"logs/{path}/{elem}" for path in os.listdir("logs/") for elem in os.listdir(f"logs/{path}/")]
    send_email(subject = "Snakemake workflow - FAILURE", 
            body = "Check the attachments for the failing logs.",
            attachments=attachments, 
            recipients=recipients, 
            sender=sender,
            app_password=app_password
    )